# coding: utf-8

from __future__ import division
from openerp import api, fields, models, _
from odoo.exceptions import ValidationError


class SaleOrderLine(models.Model):

    _inherit = 'sale.order.line'

    def _get_purchase_partner_id(self):
        suppliers = self.env['product.supplierinfo'].search_read([
            ('product_id', '=', self.product_id.id)], ['name'])
        return [('id', 'in', [x['name'][0] for x in suppliers])]

    purchase_partner_id = fields.Many2one(
        'res.partner', string='Supplier for purchase',
        domain=_get_purchase_partner_id,
        help='In this field can be defined the supplier you want to make'
        ' the purchase that is generated by a special sale order.')

    special_sale = fields.Boolean(
        compute='_compute_is_special_sale',
        help='True if there is a buy type procurement rule within the chosen'
        ' route, otherwise false')

    @api.multi
    def button_cancel(self):
        res = super(SaleOrderLine, self).button_cancel()
        for sale_line in self.filtered('order_id.pos'):
            move_ids = self.env['stock.move'].search([
                ('sale_order_line_id', '=', sale_line.id)])
            move_ids.action_cancel()
        return res

    @api.depends('route_id')
    def _compute_is_special_sale(self):
        for rec in self:
            pull_buy = rec.route_id.pull_ids.filtered(
                lambda dat: dat.action == 'buy')
            rec.special_sale = bool(pull_buy)

    @api.constrains('state')
    def check_margin(self):
        """Verify margin minimum in sale order line.
        """
        for sale_line in self:
            warning = sale_line.check_margin_qty(sale_line.price_subtotal)
            if warning:
                raise ValidationError(warning.get('message'))

    @api.onchange('price_unit')
    def onchange_check_margin(self):
        """Verify margin minimum in sale order line by change in field.
        """
        return {'warning': self.check_margin_qty()}

    def check_margin_qty(self, price_subtotal=False):
        """Verify quantity of margin minimum in sale order line for onchange.
        """
        res = {
            'message': _(
                'The product [%s] %s %s can not be sold below the allowed '
                'margin\nContact Manager') % (
                    self.product_id.default_code, self.product_id.name,
                    ','.join(self.product_id.attribute_value_ids.mapped(
                        'name')))}
        if self.env.user.has_group(
                'typ_sale.res_group_can_sell_below_minimum_margin'):
            return
        if not price_subtotal:
            price_subtotal = self.price_subtotal

        if price_subtotal == 0 and not self.product_id:
            return

        if price_subtotal <= 0 and self.product_id:
            return res

        cur = self.order_id.pricelist_id.currency_id
        margin = self.env.user.company_id.margin_allowed
        if self.product_id and self.product_id.standard_price:
            tmp_standard_price = self.env.user.company_id.currency_id.compute(
                self.product_id.standard_price, cur)
            tmp_margin = price_subtotal - (tmp_standard_price *
                                           self.product_uom_qty)
        else:
            tmp_margin = price_subtotal - (self.purchase_price *
                                           self.product_uom_qty)

        purchase_sale = cur.round(tmp_margin)

        margin_sale = (purchase_sale / price_subtotal) * 100
        if margin_sale < margin:
            return res

    @api.onchange('price_unit')
    def _onchange_price_unit(self):
        """Method to restrict change of price of sale"""
        if (self.env.user.has_group('typ_sale.res_group_modify_price_sale') or
                not (self.order_id.pricelist_id and self.order_id.partner_id)):
            return
        tmp_price_unit = self.price_unit
        self.product_uom_change()
        if (self.product_id.type != 'service' and
                self.price_unit != tmp_price_unit and
                not self.product_id.categ_id.allow_change_price_sale):
            raise ValidationError(
                _("You can not modify the price sale of product %s") % (
                    self.product_id.name))
        self.price_unit = tmp_price_unit

    def invoice_line_create(self, invoice_id, qty):
        move_model = self.env['stock.move']
        landed_model = self.env['stock.landed.cost']
        invoice_lines = super().invoice_line_create(invoice_id, qty)
        for invoice_line in invoice_lines:
            moves = move_model.search([
                ('sale_line_id', 'in', invoice_line.sale_line_ids.ids),
                ('state', '=', 'done'), ('scrapped', '!=', True)])
            dat = moves.mapped('move_orig_logistic_ids.origin_move_id')
            landed = landed_model.search(
                [('move_ids', 'in', dat.ids),
                 ('l10n_mx_edi_customs_number', '!=', False)])
            invoice_line.update({'l10n_mx_edi_customs_number': ','.join(
                list(set(landed.mapped('l10n_mx_edi_customs_number'))))})
        return invoice_lines


class ProcurementRule(models.Model):
    _inherit = 'procurement.rule'

    def _make_po_select_supplier(self, values, suppliers):
        move = values.get('move_dest_ids')
        while move and move.move_dest_ids:
            move = move.move_dest_ids
        if move and move.sale_line_id.purchase_partner_id:
            partner_id = move.sale_line_id.purchase_partner_id
            suppliers = move.product_id.seller_ids.search(
                [('name', 'in', partner_id.ids)])
        res = super(ProcurementRule, self)._make_po_select_supplier(
            values, suppliers)
        return res
